#!/bin/bash
# Deployment automation script
# Usage: ./.claude/commands/deploy <environment> [options]

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
ENVIRONMENTS=("staging" "production")
DEFAULT_ENVIRONMENT="staging"

# Utility functions
log() {
    echo -e "${GREEN}[DEPLOY]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Show help
show_help() {
    echo "Deployment Automation Script"
    echo
    echo "Usage: $0 <environment> [options]"
    echo
    echo "Environments:"
    echo "  staging      Deploy to staging environment"
    echo "  production   Deploy to production environment (requires confirmation)"
    echo
    echo "Options:"
    echo "  --skip-tests       Skip test execution"
    echo "  --skip-build       Skip build step"
    echo "  --skip-migrations  Skip database migrations"
    echo "  --force           Force deployment without confirmation"
    echo "  --dry-run         Show what would be deployed without actually deploying"
    echo "  --help            Show this help message"
    echo
    echo "Examples:"
    echo "  $0 staging                    # Deploy to staging"
    echo "  $0 production --force         # Force deploy to production"
    echo "  $0 staging --skip-tests       # Deploy without running tests"
    echo "  $0 production --dry-run       # Show production deployment plan"
    echo
}

# Validate environment
validate_environment() {
    local env="$1"
    
    if [[ ! " ${ENVIRONMENTS[@]} " =~ " ${env} " ]]; then
        error "Invalid environment: $env"
        echo "Valid environments: ${ENVIRONMENTS[*]}"
        exit 1
    fi
}

# Check if all required environment variables are set
check_environment_variables() {
    local env="$1"
    local missing_vars=()
    
    # Common variables
    local required_common=(
        "VERCEL_TOKEN"
        "VERCEL_ORG_ID" 
        "VERCEL_PROJECT_ID"
        "SUPABASE_ACCESS_TOKEN"
    )
    
    # Environment specific variables
    if [ "$env" = "production" ]; then
        local required_prod=(
            "SUPABASE_PROJECT_REF_PRODUCTION"
            "SUPABASE_URL_PRODUCTION"
            "SUPABASE_ANON_KEY_PRODUCTION"
            "PRODUCTION_URL"
        )
        required_common+=("${required_prod[@]}")
    else
        local required_staging=(
            "SUPABASE_PROJECT_REF_STAGING"
            "SUPABASE_URL_STAGING"
            "SUPABASE_ANON_KEY_STAGING"
            "STAGING_URL"
        )
        required_common+=("${required_staging[@]}")
    fi
    
    # Check each variable
    for var in "${required_common[@]}"; do
        if [ -z "${!var}" ]; then
            missing_vars+=("$var")
        fi
    done
    
    if [ ${#missing_vars[@]} -gt 0 ]; then
        error "Missing required environment variables:"
        for var in "${missing_vars[@]}"; do
            echo "  - $var"
        done
        echo
        echo "Please set these variables in your environment or .env file"
        exit 1
    fi
}

# Check if Git working directory is clean
check_git_status() {
    if [ "$SKIP_GIT_CHECK" = "true" ]; then
        warn "Skipping git status check"
        return
    fi
    
    if ! git diff-index --quiet HEAD --; then
        error "Working directory is not clean. Please commit or stash changes first."
        echo
        echo "Uncommitted changes:"
        git status --porcelain
        exit 1
    fi
    
    # Check if we're on the main branch for production
    if [ "$ENVIRONMENT" = "production" ]; then
        local current_branch=$(git branch --show-current)
        if [ "$current_branch" != "main" ]; then
            error "Production deployments must be from main branch"
            echo "Current branch: $current_branch"
            exit 1
        fi
    fi
}

# Run pre-deployment tests
run_tests() {
    if [ "$SKIP_TESTS" = "true" ]; then
        warn "Skipping tests"
        return
    fi
    
    log "Running test suite..."
    
    # Run linting
    log "Running linting..."
    npm run lint:strict
    
    # Run type checking
    log "Running type checking..."
    npm run type-check
    
    # Run unit tests
    log "Running unit tests..."
    npm run test:unit
    
    # Run integration tests if in CI or explicitly enabled
    if [ "${CI:-false}" = "true" ] || [ "${RUN_INTEGRATION_TESTS:-false}" = "true" ]; then
        log "Running integration tests..."
        npm run test:integration
    else
        info "Skipping integration tests (set RUN_INTEGRATION_TESTS=true to enable)"
    fi
    
    log "✅ All tests passed"
}

# Build application
build_application() {
    if [ "$SKIP_BUILD" = "true" ]; then
        warn "Skipping build"
        return
    fi
    
    log "Building application..."
    
    # Set environment-specific build variables
    if [ "$ENVIRONMENT" = "production" ]; then
        export NEXT_PUBLIC_SUPABASE_URL="$SUPABASE_URL_PRODUCTION"
        export NEXT_PUBLIC_SUPABASE_ANON_KEY="$SUPABASE_ANON_KEY_PRODUCTION"
    else
        export NEXT_PUBLIC_SUPABASE_URL="$SUPABASE_URL_STAGING"
        export NEXT_PUBLIC_SUPABASE_ANON_KEY="$SUPABASE_ANON_KEY_STAGING"
    fi
    
    # Build with optimization
    NODE_OPTIONS="--max-old-space-size=8192" npm run build
    
    log "✅ Application built successfully"
}

# Run database migrations
run_migrations() {
    if [ "$SKIP_MIGRATIONS" = "true" ]; then
        warn "Skipping database migrations"
        return
    fi
    
    log "Running database migrations for $ENVIRONMENT..."
    
    # Authenticate with Supabase
    echo "$SUPABASE_ACCESS_TOKEN" | supabase auth login --token -
    
    # Link to correct project
    if [ "$ENVIRONMENT" = "production" ]; then
        supabase link --project-ref "$SUPABASE_PROJECT_REF_PRODUCTION"
        export SUPABASE_DB_PASSWORD="$SUPABASE_DB_PASSWORD_PRODUCTION"
    else
        supabase link --project-ref "$SUPABASE_PROJECT_REF_STAGING"
        export SUPABASE_DB_PASSWORD="$SUPABASE_DB_PASSWORD_STAGING"
    fi
    
    # Run migrations with dry-run first for production
    if [ "$ENVIRONMENT" = "production" ]; then
        log "Running migration dry-run for production..."
        supabase db push --dry-run
        
        if [ "$FORCE_DEPLOY" != "true" ]; then
            read -p "Proceed with production migrations? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                log "Migration cancelled"
                exit 1
            fi
        fi
    fi
    
    # Apply migrations
    supabase db push
    
    # Update TypeScript types
    log "Updating TypeScript types..."
    if [ "$ENVIRONMENT" = "production" ]; then
        SUPABASE_PROJECT_ID="$SUPABASE_PROJECT_REF_PRODUCTION" npm run supabase:types:remote
    else
        SUPABASE_PROJECT_ID="$SUPABASE_PROJECT_REF_STAGING" npm run supabase:types:remote
    fi
    
    log "✅ Database migrations completed"
}

# Deploy to Vercel
deploy_to_vercel() {
    log "Deploying to Vercel ($ENVIRONMENT)..."
    
    if [ "$DRY_RUN" = "true" ]; then
        log "DRY RUN: Would deploy to $ENVIRONMENT environment"
        return
    fi
    
    # Set deployment command
    local deploy_cmd="npx vercel --prod --token $VERCEL_TOKEN"
    
    # Add environment variables
    if [ "$ENVIRONMENT" = "production" ]; then
        deploy_cmd="$deploy_cmd --env NEXT_PUBLIC_SUPABASE_URL=$SUPABASE_URL_PRODUCTION"
        deploy_cmd="$deploy_cmd --env NEXT_PUBLIC_SUPABASE_ANON_KEY=$SUPABASE_ANON_KEY_PRODUCTION"
        deploy_cmd="$deploy_cmd --env SUPABASE_SERVICE_ROLE_KEY=$SUPABASE_SERVICE_ROLE_KEY_PRODUCTION"
    else
        deploy_cmd="$deploy_cmd --env NEXT_PUBLIC_SUPABASE_URL=$SUPABASE_URL_STAGING"
        deploy_cmd="$deploy_cmd --env NEXT_PUBLIC_SUPABASE_ANON_KEY=$SUPABASE_ANON_KEY_STAGING"
        deploy_cmd="$deploy_cmd --env SUPABASE_SERVICE_ROLE_KEY=$SUPABASE_SERVICE_ROLE_KEY_STAGING"
    fi
    
    # Execute deployment
    eval $deploy_cmd
    
    # Get deployment URL
    local deployment_url
    if [ "$ENVIRONMENT" = "production" ]; then
        deployment_url="$PRODUCTION_URL"
    else
        deployment_url="$STAGING_URL"
    fi
    
    log "✅ Deployment successful: $deployment_url"
}

# Run post-deployment health checks
run_health_checks() {
    log "Running post-deployment health checks..."
    
    local base_url
    if [ "$ENVIRONMENT" = "production" ]; then
        base_url="$PRODUCTION_URL"
    else
        base_url="$STAGING_URL"
    fi
    
    # Wait for deployment to be ready
    log "Waiting for deployment to be ready..."
    sleep 30
    
    # Basic health check
    if curl -f "$base_url/api/health" > /dev/null 2>&1; then
        log "✅ Health check passed"
    else
        error "❌ Health check failed"
        exit 1
    fi
    
    # Additional smoke tests
    if curl -f "$base_url/" > /dev/null 2>&1; then
        log "✅ Landing page accessible"
    else
        warn "⚠️ Landing page check failed"
    fi
    
    log "✅ Post-deployment checks completed"
}

# Send deployment notification
send_notification() {
    local status="$1"
    local message="$2"
    
    if [ -z "$SLACK_WEBHOOK_URL" ]; then
        info "No Slack webhook configured, skipping notification"
        return
    fi
    
    local color="good"
    local emoji="✅"
    
    if [ "$status" = "failure" ]; then
        color="danger"
        emoji="❌"
    fi
    
    local payload=$(cat <<EOF
{
  "attachments": [
    {
      "color": "$color",
      "fields": [
        {
          "title": "$emoji Deployment $status",
          "value": "$message",
          "short": false
        },
        {
          "title": "Environment",
          "value": "$ENVIRONMENT",
          "short": true
        },
        {
          "title": "Branch",
          "value": "$(git branch --show-current)",
          "short": true
        },
        {
          "title": "Commit",
          "value": "$(git rev-parse --short HEAD)",
          "short": true
        }
      ]
    }
  ]
}
EOF
    )
    
    curl -X POST -H 'Content-type: application/json' \
        --data "$payload" "$SLACK_WEBHOOK_URL" > /dev/null 2>&1 || true
}

# Main deployment function
deploy() {
    local start_time=$(date +%s)
    
    log "Starting deployment to $ENVIRONMENT"
    log "Timestamp: $(date)"
    log "Branch: $(git branch --show-current)"
    log "Commit: $(git rev-parse --short HEAD)"
    
    if [ "$DRY_RUN" = "true" ]; then
        warn "DRY RUN MODE - No actual deployment will occur"
    fi
    
    # Confirmation for production
    if [ "$ENVIRONMENT" = "production" ] && [ "$FORCE_DEPLOY" != "true" ] && [ "$DRY_RUN" != "true" ]; then
        warn "You are about to deploy to PRODUCTION!"
        read -p "Are you sure? Type 'yes' to continue: " -r
        if [ "$REPLY" != "yes" ]; then
            log "Deployment cancelled"
            exit 0
        fi
    fi
    
    # Execute deployment steps
    check_git_status
    check_environment_variables "$ENVIRONMENT"
    run_tests
    build_application
    run_migrations
    deploy_to_vercel
    run_health_checks
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    log "🎉 Deployment completed successfully in ${duration}s"
    send_notification "success" "Deployment to $ENVIRONMENT completed successfully in ${duration}s"
}

# Parse command line arguments
parse_arguments() {
    ENVIRONMENT="$DEFAULT_ENVIRONMENT"
    SKIP_TESTS="false"
    SKIP_BUILD="false"
    SKIP_MIGRATIONS="false"
    FORCE_DEPLOY="false"
    DRY_RUN="false"
    SKIP_GIT_CHECK="false"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            staging|production)
                ENVIRONMENT="$1"
                shift
                ;;
            --skip-tests)
                SKIP_TESTS="true"
                shift
                ;;
            --skip-build)
                SKIP_BUILD="true"
                shift
                ;;
            --skip-migrations)
                SKIP_MIGRATIONS="true"
                shift
                ;;
            --force)
                FORCE_DEPLOY="true"
                shift
                ;;
            --dry-run)
                DRY_RUN="true"
                shift
                ;;
            --skip-git-check)
                SKIP_GIT_CHECK="true"
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    validate_environment "$ENVIRONMENT"
}

# Error handling
handle_error() {
    local exit_code=$?
    local line_number=$1
    
    error "Deployment failed at line $line_number with exit code $exit_code"
    send_notification "failure" "Deployment to $ENVIRONMENT failed at line $line_number"
    
    exit $exit_code
}

# Set up error handling
trap 'handle_error $LINENO' ERR

# Make sure we're in the project root
cd "$(dirname "$0")/../.."

# Check if required tools are installed
for tool in git npm supabase curl; do
    if ! command -v $tool &> /dev/null; then
        error "$tool is required but not installed"
        exit 1
    fi
done

# Main execution
parse_arguments "$@"
deploy